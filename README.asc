:toc: macro
:toc-title: Contents
:toclevels: 3
:experimental:

= Automated Release

Put your version control in autopilot and create good looking releases.

Don't waste time on every release searching what has changed on your software or on how to build a meaningful file for each version so your clients can see what's new. Only having https://nodejs.org/en/download/package-manager/[Node.js], you can handle all the release process in any OS. Just works!

And with the good help of https://www.docker.com/[Docker] (and Docker Compose), avoid some extra installations. Node.js will be mandatory because at the moment there is no good looking way to define Node.js path pointing to a container, and respecting cross-platform compatibility. The right path is necessary due to the Git hooks. For now, installing Node.js locally would be a better alternative. But, if you know a way to improve this code to avoid Node.js favoring the use of Docker, please, open an issue or submit a pull request. Your help is welcome!

And if you are using GitHub, make everything work on an automated way with https://travis-ci.com/[Travis-CI] (using a single file!).

Now commits like `Fixed a little bug...`, `i dunno, maybe this works` or `TODO: write meaningful commit message` will all be blocked by the _conventional commits_ rules. By the way, funny suggestions from https://whatthecommit.com[this site].

image::images/funny-commits.png[Funny Commits]

toc::[]

== Principles to apply to your project

* Now every commit needs to respect the pattern of https://www.conventionalcommits.org[conventional commits]. See below how to configure your local development to follow the commit rules quickly.

* Create a main streamline development branch, like `dev` or `development`, and make `master` as a _read-only_ branch. +
All commits to `master` will be done by merges and/or Pull Requests. So every time this operation happen, an automatic release will be generated according to the latest commits. +
This magic will happen with the help from another project, https://github.com/semantic-release/semantic-release[semantic-release], that will analyze all your most recent commits and create your next release number. Everything fully automated.
+
[NOTE]
--
Avoid creating multiple branches that may lead you to painful merge problems. The side branch development is to favor the automated release. Consider as a `trunk`/`master` development strategy where everyone commits on the same branch, following DevOps culture.

Following this pattern, you need to merge this side branch when you need to generate a new release, avoiding a new version after every commit on the `master` branch.
--

== Getting Started

Basically, you will need two main steps to get your project ready. First, configure your local tools like Node.js and Docker. Second, configure your automation server. In this case, Travis CI, that it's free to any Open Source project at GitHub.

=== Local Configuration

Here we have the first mandatory installation. Before running the first command, you will need to install Node.js on your local machine. For now, there is no way to avoid this due to the Git hooks project configuration. Download and install following https://nodejs.org/en/download/[this guide]. I would recommend you to https://nodejs.org/en/download/package-manager/[install via a package manager] from your OS.

After installation, you will have `node` and also `npm`. Execute the following command:

[source,console]
```
npm i
```

Great! Now everything will be installed based on the `package.json` file.

Now if you execute `npm run commit`, you will get help to create all your commits using conventional commits pattern. It's necessary to add all the needed files before this step. This one was only to have fun. You can abort using kbd:[CTRL + C].

image::images/npm-run-commit.png[npm run commit]

=== Project Configuration

You may want to update `package.json` configuration file to fit your project. Here it is the main changes you need to do:

* `"author"` -> Your name.
* `"name"` -> Project's name.
* `"description"` -> Project description.
* `"license"` -> Project license.
* `"repository"` -> Repository info.
* `"bugs"` -> Place to report bugs.
* `"homepage"` -> Project homepage.
* `"keywords"` -> Keywords related to the project.

Another file that is important to the project is the `changelog.config.js`. This will be the helper that will guide all the commits from the project. It's a sharable configuration so that all contributors will use the same rules. The basic config is following the https://github.com/streamich/git-cz#custom-config[default configuration] adding some scopes related to this current project. But there are other ways to style the commits, like the https://github.com/atom/atom/blob/master/CONTRIBUTING.md#git-commit-messages[atom project]. Change on the way you want to feat to your needs.

Here are some changed configurations, like the scope section:

.before
```
"scopes": [],
```

.after
```
"scopes": [
    "",
    "readme",
    "core"
],
```

The empty `scope` is to favor commits that don't have a related scope. And by the way, `scope` values *must* be lowercase.

=== GitHub

First, you will need to generate an API token from GitHub. According to the https://github.com/semantic-release/cli#what-it-does[semantic-version documentation] (see step 3), the https://github.com/settings/tokens[GitHub Access Token] needs the following permissions: _repo, read:org, repo:status, repo_deployment, user:email, write:repo_hook_.

The step-by-step process is fully documented in this https://help.github.com/en/articles/creating-a-personal-access-token-for-the-command-line[GitHub article].

image::images/github-select-scopes.png[GitHub Access Token - Select scopes]

Define a name like "_automatic releases for rcmoutinho/automated-release_", select the scopes and generate the token. The result will be displayed on the screen *only once*! Something like this:

```
myTokenWithLotsOfNumbersAndLetters123456
```

image::images/personal-access-tokens.png[GitHub - Personal access tokens]

Great! Save this value and treat it as a [.underline]#*_very important password!_*# Seriously! It will be used to configure the `$GITHUB_TOKEN` for Travis CI automation.

For now, we are good with the GitHub configuration.

NOTE: *TODO!* Find a way to transform this step into an automated one! Sorry about this manual step for now :(

=== Travis CI

Considering that you are going to use the same project configuration for Travis CI, `.travis.yml`, you will only need to remove the secure variable used by this project and configure yours.

[source,yml]
```
# ...
env:
  global:
    secure: <ENCRYPTED_TOKEN>
# ...
```

To ease this process, let's use the Travis CLI. Check https://github.com/travis-ci/travis.rb#installation[this documentation] to see the specific installation to your OS.

. Make sure you are on the root of the project. This is important to get some Git configuration during the process.

. https://github.com/travis-ci/travis.rb#login[Login] using the travis CLI using your GitHub credentials.
+
```
travis login --com
```

. Enable the GitHub project on Travis CI.
+
```
travis enable
```
+
NOTE: Don't need to execute `init` because we already have the project configuration defined.

. Encrypt the GitHub token.
+
```
travis encrypt GITHUB_TOKEN="myTokenWithLotsOfNumbersAndLetters123456" --repo username/project-name --com --add
```
* The `--repo` parameter is optional. The CLI will try to suggest considering the git remote configuration.
+
```
Detected repository as rcmoutinho/automated-release, is this correct? |yes|
```
* More about Travis CI encryption process, https://docs.travis-ci.com/user/encryption-keys/[here].
* More about _semantic-release_ authentication needs, https://semantic-release.gitbook.io/semantic-release/usage/ci-configuration#authentication[here].

. Check your `.travis.yml` to see your new encrypted value.

That's it! Now your project has a fully automated version releases control.

TIP: All this process could be avoided using the https://github.com/semantic-release/cli#semantic-release-cli[_semantic-release-cli setup_], but this isn't a project that we need to upload to npm registry. That's why all this specific configuration is necessary to skip npm configuration.

NOTE: *TODO!* (another one!) Create a configuration to use travis CLI using docker, avoid local installations.

== Deeper on the code!

On the following sections, there are extra configurations and explanation about the project.

=== Productive Commits

* `npm run commit` -> This is the main command to commit your changes using the pattern of conventional commits.
* `git cz` -> Configure a git command, on a project level to avoid conflicts, to ease the use of this pattern. Behind the scenes, it will call the same npm command.
+
.unix/linux
```
git config --local alias.cz '!npm run commit'
```
+
.windows (just need double quotes instead of single quotes)
```
git config --local alias.cz "!npm run commit"
```
+
..git/config (local project configuration)
```
[alias]
	cz = !npm run commit
```
+
If you set this configuration as global, you will need this node script configuration on any project you create.

=== Travis Builds and New Releases

Don't worry about pushing more than one commit to the branch watched by Travis (probably `master`) at the same time. It will only trigger a new build considering the last commit of this batch, as it's shown on the following image, with two _feature_ commits on the same release.

image::images/github-commits-release.png[GitHub Commits and Release]

_semantic-release_ triggers new releases analyzing commits with _feat_, _fix_, _perf_ or _breaking change_. If you want to know more how does it works, check this https://github.com/semantic-release/semantic-release/blob/master/docs/support/FAQ.md#how-can-i-change-the-type-of-commits-that-trigger-a-release[great explanation on their docs].

=== git-cz

Quick tips on how to get the best of this library. Let's follow each step after a `git-cz` (or `npm run commit`):

* Select the type according to the options.
+
```
? Select the type of change that you're committing:
```
* _[optional]_ Defines the scope, if there are available options on the project's configuration.
+
```
? Select the scope this component affects:
```
* Write your best message with the remaining space. This will be the message shown on the release notes. So it's essential to be a meaningful message to the developer (and maybe the user).
+
```
? Write a short, imperative mood description of the change:`
[-------------------------------------------------------------] 55 chars left
<type>[(<scope>)]:
```
* _[optional]_ Time to write everything you need that makes easier to understand the changes made on this commit. Do your best. And also, if you wanna just to refer an issue on GitHub, do it here with the `#<number>`. The next step will automatically close the issue.
+
```
? Provide a longer description of the change:
```
* _[optional]_ Is this commit breaks the software compatibility? So it's time to write why it's happened. This step will force a new major release on the next automated build on `master`.
+
```
? List any breaking changes
  BREAKING CHANGE:
```
* _[optional]_ Just put the `#<number>` of the issue that this commit will close, if it's applicable.
+
```
? Issues this commit closes, e.g #123: #2
```

== References

* https://medium.com/@kevinkreuzer/the-way-to-fully-automated-releases-in-open-source-projects-44c015f38fd6[The way to fully automated releases in open source projects] +
    An awesome article that inspired this project. The author also created a project, https://github.com/kreuzerk/node-command-line-starter[node-command-line-starter], but more focused on automating the deploy packages to npm repository.
* Main GitHub Projects
** https://github.com/streamich/git-cz[git-cz] -> Semantic Git commits
** https://github.com/semantic-release/semantic-release[semantic-release] -> Fully automated version management and package publishing

== License

MIT License
2019 © Rodrigo Moutinho and https://github.com/rcmoutinho/automated-release/cli/graphs/contributors[contributors]
